Chapters:
1. SB Core
2. SB Data JPA
3. SB MongoDB
4. SB Web MVC
5. SB E-Mail
6. SB Batch Processing
7. SB REST (Provider & Consumer)

Notes:

CHAPTER 1. SB CORE:
------------------
=> SB is an Abstract Maven Project also called as Parent Maven Project (i.e. A project with partial code).
=> SB provides AUTO CONFIGURATION which means reduce common lines of code in application which is writtern by programmers and handle jars with version management.
  (i.e. Providing configuration code XML / Java and maintaining all jars required for Project Parent Jars + Child Jars).
=> Here programmer will not write configuration code but need to give input data using 
  a) Properties File (application.properties)
  b) YAMAL File (application.yml)
=> SB supports end to end process that is called
  Coding -> Unit testing -> Version control -> Build -> Deployment -> Client Integration
=> SB application is a service provider app which can be integrated with any UI client like Android, Angular UI, Any 3rd party apps, web apps using Rest and JMS.
=> SB supports two build tools 
    1) MAVEN 
    2) GRADEL
=> SB supports three embeded servers 
    1) Apache Tomcat (default) 
    2) JBoss Jetty 
    3) Undertow
=> SB supports three embeded databases
    1) H2
    2) HSQL DB
    3) Apache Derby

=> SB STARTER CLASS: It is a main method class used to start our app. It's entry point in execution. Even for both stand alone and web application.

SB RUNNERS:
***********
=> A Runner is an auto-executable component which is called by container on application startup only once.
=> In this concept is used to execute any login (code) one time when application is started.
  Types of Runners
    1. COMMANDLINE RUNNER: This is legacy runner (old one) which is provided in SB 1.0 version.
      =>It has only one abstract method “run(String… args) : void”.
      =>It is a Functional Interface (having only one abstract method).
      =>Add one stereotype Annotation over Implementation class level (Ex:- @Component). So that container can detect the class and create object to it.

      Q>  How CommandLineRunner works?
      A>  CommandLine arguments which are passed to application which will be given to Spring Boot starter main(..) method. Those are stored as “string Array” (String[]).
          SpringApplication.run(…) reads this input and internally calls run(..) methods of RunnerImpl classes and pass same data.

    2 ApplicationRunner(I) :-- It is new type runner added in Spring boot 1.3 which makes easy to access arguments.
        =>This will separate Option Arguments (as Map<String, List<String>>) and Non-Option Arguments (<List<String>)
        =>This Data Stored in Object

      Q> What is the difference between CommandLineArgument and ApplicationRunner?
      A> Working process of CommandLineRunner and ApplicationRunner are same, but CommandLineRunner (CLR) holds data in String[] format where as Application (AR) holds data as 
          ApllicationArguments as Option/Non-Option format.

@ConfigurationProperties:
*************************
  =>This Annotation is used to perform bulk data reading (multiple keys at a time) and parsing into one class type (Stores in project).
  =>Possible conversions are.
    a> 1key = 1 variable
    b> Multiple keys with index = List/Set/Array
    c> Multiple keys with key-value format = Map or Properties
    d> Multiple keys with common type = Class Object (Has-A)

pom.xml (Maven Process) :
*************************
=>Maven is Dependency management and build tool used to handle both stand alone and Archetype (web, restful…) applications.

Dependency Management:
**********************
=> Getting Main Jars and its child jars with version support (without conflicts) into project workspace is called as Dependency Management.

Build:
******
=>Converting our application into final JAVA executable format i.e .jar/.war/.ear.

Major components of pom.xml:
****************************
  1>  Current Project
  2>  Parent Project
  3>  Dependencies
  4>Build plugins

Dependency exclusions:
**********************
=> When <dependency> tag is added in pom.xml then it will download Parent jars and all its child jars also.
=> To avoid any one or more child jars from chain, use concept called exclusion.
  Syntax:--
    <dependencies>
     <dependency>
        <groupId>..</groupId>
        <artifactId>..</artifactId>
        <version>..</version>
        <exclusions>
         <exclusion>
           <groupId>..</groupId>
           <artifactId>..</artifactId>
         </exclusion>
       </exclusions>
     </dependency>
    </dependencies>

Scope (<scope> </scope> in dependency:
**************************************
=> For every dependency one scope is given by maven i.e. default scope : compile.
=> This tag is optional and indicates when a JAR should be used/loaded.

    POM format:
      <dependency>
         <groupId>…</groupId>
         <artifactId>…</artifactId>
         <scope>….</scope>
      </dependency>

Possible Maven dependency scopes are (5) :
  1> compile:-- A jar Required from compilation time onwards. It is only default scope.
  2> runtime:-- A jar required when we are running an Application, not before that.
  3> test:-- A Jar required only for UnitTesting time.
  4> provided:-- A jar provided by servers or Frameworks (Container….).
  5> system:-- A Jar loaded from File System (like D:/abc/myjar/…)
      =>In this case we should also give <SystemPath> with location of JAR.Ex:-- <systemPath>D:/asf/lib/</systemPath>
      
NOTE:-- There is a dependency jar which not existing in the maven centre but locally.After mvn clean install, this dependency jar can't be found from the fat jar. is this an 
known-issue? the workaround is have to install it into local maven repo with command:
    `mvn install:install-file -Dfile=lib/routines.jar -DgroupId=org.talend -DartifactId=routines -Dversion=1.0 -Dpackaging=jar`
=>Then using normal dependency format in the pom.xml like this:
   <dependency>
       <groupId>org.talend</groupId>
       <artifactId>routines</artifactId>
       <version>1.0</version>
    </dependency>

Maven Goals Execution:
**********************
1> Maven clean:-- It is used to clear target folder in maven project. i.e delete all old files from target.
2> Maven install :-- It will downloaded all required plugins and also
  =>compile the source files.
  =>load required properties.
  =>Execute JUnit Test cases.
  =>Create final build (.jar/.war).

Use of Starter class:
*********************
1> Define Spring Container.
  =>Spring container holds all required beans (Objects), this is created using Impl class. AnnotationConfigApplicationContext (C) for simple (non-server) based application.
  =>For server based Application, Impl class is : AnnotationConfigServletWebServerApplicationContext (C).
2> Here “Starter class Package” behaves as basePackage, if nothing is provided by programmer.
=>If Programmer writes externally @ComponentScan then Starter class package never taken as basePackage.
=>Spring Boot starter class package behaves as base package for componentScan of all classes having annotated with @Component [or its equal].
=>Annotations are : (class should have any one)
   a> @Component
   b> @Repository
   c> @Service
   d> @Controller
   e> @RestController
   f> @Configuration

3.> Every Spring Boot Application Starter class itself Component. i.e @SpringBootApplication is having @Component annotation internally.
    => It is only highest Priority component by default, if app has multiple components.
        Ex:- We can convert starter even as Runner.

4> Auto-Detect and Execute Configuration classes [Auto-Load Configuration files]
  =>Every Spring Boot starter class itself A configuration class (@Configuration) which auto detects other Config Classes even without @Import annotation.
    i.e. We can define @Bean (Objects creation in Starter class).
  =>All Spring (Java based) Configuration files are loaded into container with @Configuration.
  =>All Spring (java based) Configuration files are loaded into container by spring boot if classes are annotated with @Configuration.
  =>Not required to pass as ApplicationContext input (as like Spring f/w)

